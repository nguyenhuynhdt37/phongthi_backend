"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectStoreService = void 0;
const config_1 = require("@n8n/config");
const di_1 = require("@n8n/di");
const aws4_1 = require("aws4");
const axios_1 = __importDefault(require("axios"));
const n8n_workflow_1 = require("n8n-workflow");
const node_crypto_1 = require("node:crypto");
const logger_1 = require("../../logging/logger");
const utils_1 = require("./utils");
let ObjectStoreService = class ObjectStoreService {
    constructor(logger, s3Config) {
        this.logger = logger;
        this.s3Config = s3Config;
        this.isReady = false;
        const { host, bucket, protocol } = s3Config;
        if (host === '') {
            throw new n8n_workflow_1.ApplicationError('External storage host not configured. Please set `N8N_EXTERNAL_STORAGE_S3_HOST`.');
        }
        if (bucket.name === '') {
            throw new n8n_workflow_1.ApplicationError('External storage bucket name not configured. Please set `N8N_EXTERNAL_STORAGE_S3_BUCKET_NAME`.');
        }
        this.baseUrl = new URL(`${protocol}://${host}/${bucket.name}`);
    }
    async init() {
        await this.checkConnection();
        this.setReady(true);
    }
    setReady(newState) {
        this.isReady = newState;
    }
    async checkConnection() {
        if (this.isReady)
            return;
        return await this.request('HEAD', '');
    }
    async put(filename, buffer, metadata = {}) {
        const headers = {
            'Content-Length': buffer.length,
            'Content-MD5': (0, node_crypto_1.createHash)('md5').update(buffer).digest('base64'),
        };
        if (metadata.fileName)
            headers['x-amz-meta-filename'] = metadata.fileName;
        if (metadata.mimeType)
            headers['Content-Type'] = metadata.mimeType;
        return await this.request('PUT', filename, { headers, body: buffer });
    }
    async get(fileId, { mode }) {
        const { data } = await this.request('GET', fileId, {
            responseType: mode === 'buffer' ? 'arraybuffer' : 'stream',
        });
        if (mode === 'stream' && (0, utils_1.isStream)(data))
            return data;
        if (mode === 'buffer' && Buffer.isBuffer(data))
            return data;
        throw new TypeError(`Expected ${mode} but received ${typeof data}.`);
    }
    async getMetadata(fileId) {
        const response = await this.request('HEAD', fileId);
        return response.headers;
    }
    async deleteOne(fileId) {
        return await this.request('DELETE', fileId);
    }
    async deleteMany(prefix) {
        const objects = await this.list(prefix);
        if (objects.length === 0)
            return;
        const innerXml = objects.map(({ key }) => `<Object><Key>${key}</Key></Object>`).join('\n');
        const body = ['<Delete>', innerXml, '</Delete>'].join('\n');
        const headers = {
            'Content-Type': 'application/xml',
            'Content-Length': body.length,
            'Content-MD5': (0, node_crypto_1.createHash)('md5').update(body).digest('base64'),
        };
        return await this.request('POST', '', { headers, body, qs: { delete: '' } });
    }
    async list(prefix) {
        const items = [];
        let isTruncated;
        let nextPageToken;
        do {
            const listPage = await this.getListPage(prefix, nextPageToken);
            if (listPage.contents?.length > 0)
                items.push(...listPage.contents);
            isTruncated = listPage.isTruncated;
            nextPageToken = listPage.nextContinuationToken;
        } while (isTruncated && nextPageToken);
        return items;
    }
    async getListPage(prefix, nextPageToken) {
        const qs = { 'list-type': 2, prefix };
        if (nextPageToken)
            qs['continuation-token'] = nextPageToken;
        const { data } = await this.request('GET', '', { qs });
        if (typeof data !== 'string') {
            throw new TypeError(`Expected XML string but received ${typeof data}`);
        }
        const { listBucketResult: page } = await (0, utils_1.parseXml)(data);
        if (!page.contents)
            return { ...page, contents: [] };
        if (!Array.isArray(page.contents))
            page.contents = [page.contents];
        page.contents.forEach((item) => {
            Object.setPrototypeOf(item, Object.prototype);
        });
        return page;
    }
    async request(method, rawPath = '', { qs, headers, body, responseType } = {}) {
        const url = new URL(this.baseUrl);
        if (rawPath && rawPath !== '/') {
            url.pathname = `${url.pathname}/${rawPath}`;
        }
        Object.entries(qs ?? {}).forEach(([key, value]) => {
            url.searchParams.set(key, String(value));
        });
        const optionsToSign = {
            method,
            service: 's3',
            region: this.s3Config.bucket.region,
            host: this.s3Config.host,
            path: `${url.pathname}${url.search}`,
        };
        if (headers)
            optionsToSign.headers = headers;
        if (body)
            optionsToSign.body = body;
        const { accessKey, accessSecret } = this.s3Config.credentials;
        const signedOptions = (0, aws4_1.sign)(optionsToSign, {
            accessKeyId: accessKey,
            secretAccessKey: accessSecret,
        });
        const config = {
            method,
            url: url.toString(),
            headers: signedOptions.headers,
        };
        if (body)
            config.data = body;
        if (responseType)
            config.responseType = responseType;
        try {
            this.logger.debug('Sending request to S3', { config });
            return await axios_1.default.request(config);
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            const message = `Request to S3 failed: ${error.message}`;
            this.logger.error(message, { config });
            throw new n8n_workflow_1.ApplicationError(message, { cause: error, extra: { config } });
        }
    }
};
exports.ObjectStoreService = ObjectStoreService;
exports.ObjectStoreService = ObjectStoreService = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [logger_1.Logger,
        config_1.S3Config])
], ObjectStoreService);
//# sourceMappingURL=object-store.service.ee.js.map