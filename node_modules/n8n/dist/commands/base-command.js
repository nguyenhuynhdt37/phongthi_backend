"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCommand = void 0;
require("reflect-metadata");
const config_1 = require("@n8n/config");
const di_1 = require("@n8n/di");
const core_1 = require("@oclif/core");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const config_2 = __importDefault(require("../config"));
const constants_1 = require("../constants");
const CrashJournal = __importStar(require("../crash-journal"));
const Db = __importStar(require("../db"));
const deduplication_1 = require("../deduplication");
const deprecation_service_1 = require("../deprecation/deprecation.service");
const test_runner_service_ee_1 = require("../evaluation.ee/test-runner/test-runner.service.ee");
const message_event_bus_1 = require("../eventbus/message-event-bus/message-event-bus");
const telemetry_event_relay_1 = require("../events/relays/telemetry.event-relay");
const expression_evaluator_1 = require("../expression-evaluator");
const external_hooks_1 = require("../external-hooks");
const external_secrets_manager_ee_1 = require("../external-secrets.ee/external-secrets-manager.ee");
const license_1 = require("../license");
const load_nodes_and_credentials_1 = require("../load-nodes-and-credentials");
const node_types_1 = require("../node-types");
const posthog_1 = require("../posthog");
const shutdown_service_1 = require("../shutdown/shutdown.service");
const workflow_history_manager_ee_1 = require("../workflows/workflow-history.ee/workflow-history-manager.ee");
class BaseCommand extends core_1.Command {
    constructor() {
        super(...arguments);
        this.logger = di_1.Container.get(n8n_core_1.Logger);
        this.instanceSettings = di_1.Container.get(n8n_core_1.InstanceSettings);
        this.shutdownService = di_1.Container.get(shutdown_service_1.ShutdownService);
        this.globalConfig = di_1.Container.get(config_1.GlobalConfig);
        this.gracefulShutdownTimeoutInS = di_1.Container.get(config_1.GlobalConfig).generic.gracefulShutdownTimeout;
        this.needsCommunityPackages = false;
    }
    async init() {
        this.errorReporter = di_1.Container.get(n8n_core_1.ErrorReporter);
        const { backendDsn, environment, deploymentName } = this.globalConfig.sentry;
        await this.errorReporter.init({
            serverType: this.instanceSettings.instanceType,
            dsn: backendDsn,
            environment,
            release: `n8n@${constants_1.N8N_VERSION}`,
            serverName: deploymentName,
            releaseDate: constants_1.N8N_RELEASE_DATE,
        });
        (0, expression_evaluator_1.initExpressionEvaluator)();
        process.once('SIGTERM', this.onTerminationSignal('SIGTERM'));
        process.once('SIGINT', this.onTerminationSignal('SIGINT'));
        this.nodeTypes = di_1.Container.get(node_types_1.NodeTypes);
        await di_1.Container.get(load_nodes_and_credentials_1.LoadNodesAndCredentials).init();
        await Db.init().catch(async (error) => await this.exitWithCrash('There was an error initializing DB', error));
        if (constants_1.inDevelopment || constants_1.inTest) {
            this.shutdownService.validate();
        }
        await this.server?.init();
        await Db.migrate().catch(async (error) => await this.exitWithCrash('There was an error running database migrations', error));
        di_1.Container.get(deprecation_service_1.DeprecationService).warn();
        if (config_2.default.getEnv('executions.mode') === 'queue' &&
            this.globalConfig.database.type === 'sqlite') {
            this.logger.warn('Scaling mode is not officially supported with sqlite. Please use PostgreSQL instead.');
        }
        const { communityPackages } = this.globalConfig.nodes;
        if (communityPackages.enabled && this.needsCommunityPackages) {
            const { CommunityPackagesService } = await Promise.resolve().then(() => __importStar(require('../services/community-packages.service')));
            await di_1.Container.get(CommunityPackagesService).checkForMissingPackages();
        }
        di_1.Container.get(message_event_bus_1.MessageEventBus);
        await di_1.Container.get(posthog_1.PostHogClient).init();
        await di_1.Container.get(telemetry_event_relay_1.TelemetryEventRelay).init();
    }
    async stopProcess() {
    }
    async initCrashJournal() {
        await CrashJournal.init();
    }
    async exitSuccessFully() {
        try {
            await Promise.all([CrashJournal.cleanup(), Db.close()]);
        }
        finally {
            process.exit();
        }
    }
    async exitWithCrash(message, error) {
        this.errorReporter.error(new Error(message, { cause: error }), { level: 'fatal' });
        await (0, n8n_workflow_1.sleep)(2000);
        process.exit(1);
    }
    async initObjectStoreService() {
        const isSelected = config_2.default.getEnv('binaryDataManager.mode') === 's3';
        const isAvailable = config_2.default.getEnv('binaryDataManager.availableModes').includes('s3');
        if (!isSelected)
            return;
        if (isSelected && !isAvailable) {
            throw new n8n_workflow_1.UserError('External storage selected but unavailable. Please make external storage available by adding "s3" to `N8N_AVAILABLE_BINARY_DATA_MODES`.');
        }
        const isLicensed = di_1.Container.get(license_1.License).isFeatureEnabled(constants_1.LICENSE_FEATURES.BINARY_DATA_S3);
        if (!isLicensed) {
            this.logger.error('No license found for S3 storage. \n Either set `N8N_DEFAULT_BINARY_DATA_MODE` to something else, or upgrade to a license that supports this feature.');
            return this.exit(1);
        }
        this.logger.debug('License found for external storage - Initializing object store service');
        try {
            await di_1.Container.get(n8n_core_1.ObjectStoreService).init();
            this.logger.debug('Object store init completed');
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            this.logger.debug('Object store init failed', { error });
        }
    }
    async initBinaryDataService() {
        try {
            await this.initObjectStoreService();
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            this.logger.error(`Failed to init object store: ${error.message}`, { error });
            process.exit(1);
        }
        const binaryDataConfig = config_2.default.getEnv('binaryDataManager');
        await di_1.Container.get(n8n_core_1.BinaryDataService).init(binaryDataConfig);
    }
    async initDataDeduplicationService() {
        const dataDeduplicationService = (0, deduplication_1.getDataDeduplicationService)();
        await n8n_core_1.DataDeduplicationService.init(dataDeduplicationService);
    }
    async initExternalHooks() {
        this.externalHooks = di_1.Container.get(external_hooks_1.ExternalHooks);
        await this.externalHooks.init();
    }
    async initLicense() {
        this.license = di_1.Container.get(license_1.License);
        await this.license.init();
        const { activationKey } = this.globalConfig.license;
        if (activationKey) {
            const hasCert = (await this.license.loadCertStr()).length > 0;
            if (hasCert) {
                return this.logger.debug('Skipping license activation');
            }
            try {
                this.logger.debug('Attempting license activation');
                await this.license.activate(activationKey);
                this.logger.debug('License init complete');
            }
            catch (e) {
                const error = (0, n8n_workflow_1.ensureError)(e);
                this.logger.error('Could not activate license', { error });
            }
        }
    }
    async initExternalSecrets() {
        const secretsManager = di_1.Container.get(external_secrets_manager_ee_1.ExternalSecretsManager);
        await secretsManager.init();
    }
    initWorkflowHistory() {
        di_1.Container.get(workflow_history_manager_ee_1.WorkflowHistoryManager).init();
    }
    async cleanupTestRunner() {
        await di_1.Container.get(test_runner_service_ee_1.TestRunnerService).cleanupIncompleteRuns();
    }
    async finally(error) {
        if (error?.message)
            this.logger.error(error.message);
        if (constants_1.inTest || this.id === 'start')
            return;
        if (Db.connectionState.connected) {
            await (0, n8n_workflow_1.sleep)(100);
            await Db.close();
        }
        const exitCode = error instanceof core_1.Errors.ExitError ? error.oclif.exit : error ? 1 : 0;
        this.exit(exitCode);
    }
    onTerminationSignal(signal) {
        return async () => {
            if (this.shutdownService.isShuttingDown()) {
                this.logger.info(`Received ${signal}. Already shutting down...`);
                return;
            }
            const forceShutdownTimer = setTimeout(async () => {
                this.logger.info(`process exited after ${this.gracefulShutdownTimeoutInS}s`);
                const errorMsg = `Shutdown timed out after ${this.gracefulShutdownTimeoutInS} seconds`;
                await this.exitWithCrash(errorMsg, new Error(errorMsg));
            }, this.gracefulShutdownTimeoutInS * 1000);
            this.logger.info(`Received ${signal}. Shutting down...`);
            this.shutdownService.shutdown();
            await this.shutdownService.waitForShutdown();
            await this.errorReporter.shutdown();
            await this.stopProcess();
            clearTimeout(forceShutdownTimer);
        };
    }
}
exports.BaseCommand = BaseCommand;
//# sourceMappingURL=base-command.js.map