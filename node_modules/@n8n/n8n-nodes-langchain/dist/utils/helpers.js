"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnectedTools = void 0;
exports.getMetadataFiltersValues = getMetadataFiltersValues;
exports.isBaseChatMemory = isBaseChatMemory;
exports.isBaseChatMessageHistory = isBaseChatMessageHistory;
exports.isChatInstance = isChatInstance;
exports.isToolsInstance = isToolsInstance;
exports.getPromptInputByType = getPromptInputByType;
exports.getSessionId = getSessionId;
exports.logAiEvent = logAiEvent;
exports.serializeChatHistory = serializeChatHistory;
exports.escapeSingleCurlyBrackets = escapeSingleCurlyBrackets;
exports.unwrapNestedOutput = unwrapNestedOutput;
const n8n_workflow_1 = require("n8n-workflow");
const N8nTool_1 = require("./N8nTool");
function hasMethods(obj, ...methodNames) {
    return methodNames.every((methodName) => typeof obj === 'object' &&
        obj !== null &&
        methodName in obj &&
        typeof obj[methodName] === 'function');
}
function getMetadataFiltersValues(ctx, itemIndex) {
    const options = ctx.getNodeParameter('options', itemIndex, {});
    if (options.metadata) {
        const { metadataValues: metadata } = options.metadata;
        if (metadata.length > 0) {
            return metadata.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {});
        }
    }
    if (options.searchFilterJson) {
        return ctx.getNodeParameter('options.searchFilterJson', itemIndex, '', {
            ensureType: 'object',
        });
    }
    return undefined;
}
function isBaseChatMemory(obj) {
    return hasMethods(obj, 'loadMemoryVariables', 'saveContext');
}
function isBaseChatMessageHistory(obj) {
    return hasMethods(obj, 'getMessages', 'addMessage');
}
function isChatInstance(model) {
    const namespace = model?.lc_namespace ?? [];
    return namespace.includes('chat_models');
}
function isToolsInstance(model) {
    const namespace = model?.lc_namespace ?? [];
    return namespace.includes('tools');
}
function getPromptInputByType(options) {
    const { ctx, i, promptTypeKey, inputKey } = options;
    const prompt = ctx.getNodeParameter(promptTypeKey, i);
    let input;
    if (prompt === 'auto') {
        input = ctx.evaluateExpression('{{ $json["chatInput"] }}', i);
    }
    else {
        input = ctx.getNodeParameter(inputKey, i);
    }
    if (input === undefined) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No prompt specified', {
            description: "Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter",
        });
    }
    return input;
}
function getSessionId(ctx, itemIndex, selectorKey = 'sessionIdType', autoSelect = 'fromInput', customKey = 'sessionKey') {
    let sessionId = '';
    const selectorType = ctx.getNodeParameter(selectorKey, itemIndex);
    if (selectorType === autoSelect) {
        if ('getBodyData' in ctx) {
            const bodyData = ctx.getBodyData() ?? {};
            sessionId = bodyData.sessionId;
        }
        else {
            sessionId = ctx.evaluateExpression('{{ $json.sessionId }}', itemIndex);
        }
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No session ID found', {
                description: "Expected to find the session ID in an input field called 'sessionId' (this is what the chat trigger node outputs). To use something else, change the 'Session ID' parameter",
                itemIndex,
            });
        }
    }
    else {
        sessionId = ctx.getNodeParameter(customKey, itemIndex, '');
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'Key parameter is empty', {
                description: "Provide a key to use as session ID in the 'Key' parameter or use the 'Connected Chat Trigger Node' option to use the session ID from your Chat Trigger",
                itemIndex,
            });
        }
    }
    return sessionId;
}
function logAiEvent(executeFunctions, event, data) {
    try {
        executeFunctions.logAiEvent(event, data ? (0, n8n_workflow_1.jsonStringify)(data) : undefined);
    }
    catch (error) {
        executeFunctions.logger.debug(`Error logging AI event: ${event}`);
    }
}
function serializeChatHistory(chatHistory) {
    return chatHistory
        .map((chatMessage) => {
        if (chatMessage._getType() === 'human') {
            return `Human: ${chatMessage.content}`;
        }
        else if (chatMessage._getType() === 'ai') {
            return `Assistant: ${chatMessage.content}`;
        }
        else {
            return `${chatMessage.content}`;
        }
    })
        .join('\n');
}
function escapeSingleCurlyBrackets(text) {
    if (text === undefined)
        return undefined;
    let result = text;
    result = result
        .replace(/(?<!{){{{(?!{)/g, '{{{{')
        .replace(/(?<!})}}}(?!})/g, '}}}}')
        .replace(/(?<!{){(?!{)/g, '{{')
        .replace(/(?<!})}(?!})/g, '}}');
    return result;
}
const getConnectedTools = async (ctx, enforceUniqueNames, convertStructuredTool = true, escapeCurlyBrackets = false) => {
    const connectedTools = (await ctx.getInputConnectionData("ai_tool", 0)) || [];
    if (!enforceUniqueNames)
        return connectedTools;
    const seenNames = new Set();
    const finalTools = [];
    for (const tool of connectedTools) {
        const { name } = tool;
        if (seenNames.has(name)) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), `You have multiple tools with the same name: '${name}', please rename them to avoid conflicts`);
        }
        seenNames.add(name);
        if (escapeCurlyBrackets) {
            tool.description = escapeSingleCurlyBrackets(tool.description) ?? tool.description;
        }
        if (convertStructuredTool && tool instanceof N8nTool_1.N8nTool) {
            finalTools.push(tool.asDynamicTool());
        }
        else {
            finalTools.push(tool);
        }
    }
    return finalTools;
};
exports.getConnectedTools = getConnectedTools;
function unwrapNestedOutput(output) {
    if ('output' in output &&
        Object.keys(output).length === 1 &&
        typeof output.output === 'object' &&
        output.output !== null &&
        'output' in output.output &&
        Object.keys(output.output).length === 1) {
        return output.output;
    }
    return output;
}
//# sourceMappingURL=helpers.js.map