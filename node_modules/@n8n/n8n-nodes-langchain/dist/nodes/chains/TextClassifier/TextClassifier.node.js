"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextClassifier = void 0;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const output_parsers_1 = require("langchain/output_parsers");
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
const tracing_1 = require("../../../utils/tracing");
const SYSTEM_PROMPT_TEMPLATE = "Please classify the text provided by the user into one of the following categories: {categories}, and use the provided formatting instructions below. Don't explain, and only output the json.";
const configuredOutputs = (parameters) => {
    const categories = parameters.categories?.categories ?? [];
    const fallback = parameters.options?.fallback;
    const ret = categories.map((cat) => {
        return { type: "main", displayName: cat.category };
    });
    if (fallback === 'other')
        ret.push({ type: "main", displayName: 'Other' });
    return ret;
};
class TextClassifier {
    constructor() {
        this.description = {
            displayName: 'Text Classifier',
            name: 'textClassifier',
            icon: 'fa:tags',
            iconColor: 'black',
            group: ['transform'],
            version: 1,
            description: 'Classify your text into distinct categories',
            codex: {
                categories: ['AI'],
                subcategories: {
                    AI: ['Chains', 'Root Nodes'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.text-classifier/',
                        },
                    ],
                },
            },
            defaults: {
                name: 'Text Classifier',
            },
            inputs: [
                { displayName: '', type: "main" },
                {
                    displayName: 'Model',
                    maxConnections: 1,
                    type: "ai_languageModel",
                    required: true,
                },
            ],
            outputs: `={{(${configuredOutputs})($parameter)}}`,
            properties: [
                {
                    displayName: 'Text to Classify',
                    name: 'inputText',
                    type: 'string',
                    required: true,
                    default: '',
                    description: 'Use an expression to reference data in previous nodes or enter static text',
                    typeOptions: {
                        rows: 2,
                    },
                },
                {
                    displayName: 'Categories',
                    name: 'categories',
                    placeholder: 'Add Category',
                    type: 'fixedCollection',
                    default: {},
                    typeOptions: {
                        multipleValues: true,
                    },
                    options: [
                        {
                            name: 'categories',
                            displayName: 'Categories',
                            values: [
                                {
                                    displayName: 'Category',
                                    name: 'category',
                                    type: 'string',
                                    default: '',
                                    description: 'Category to add',
                                    required: true,
                                },
                                {
                                    displayName: 'Description',
                                    name: 'description',
                                    type: 'string',
                                    default: '',
                                    description: "Describe your category if it's not obvious",
                                },
                            ],
                        },
                    ],
                },
                {
                    displayName: 'Options',
                    name: 'options',
                    type: 'collection',
                    default: {},
                    placeholder: 'Add Option',
                    options: [
                        {
                            displayName: 'Allow Multiple Classes To Be True',
                            name: 'multiClass',
                            type: 'boolean',
                            default: false,
                        },
                        {
                            displayName: 'When No Clear Match',
                            name: 'fallback',
                            type: 'options',
                            default: 'discard',
                            description: 'What to do with items that donâ€™t match the categories exactly',
                            options: [
                                {
                                    name: 'Discard Item',
                                    value: 'discard',
                                    description: 'Ignore the item and drop it from the output',
                                },
                                {
                                    name: "Output on Extra, 'Other' Branch",
                                    value: 'other',
                                    description: "Create a separate output branch called 'Other'",
                                },
                            ],
                        },
                        {
                            displayName: 'System Prompt Template',
                            name: 'systemPromptTemplate',
                            type: 'string',
                            default: SYSTEM_PROMPT_TEMPLATE,
                            description: 'String to use directly as the system prompt template',
                            typeOptions: {
                                rows: 6,
                            },
                        },
                        {
                            displayName: 'Enable Auto-Fixing',
                            name: 'enableAutoFixing',
                            type: 'boolean',
                            default: true,
                            description: 'Whether to enable auto-fixing (may trigger an additional LLM call if output is broken)',
                        },
                    ],
                },
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const llm = (await this.getInputConnectionData("ai_languageModel", 0));
        const categories = this.getNodeParameter('categories.categories', 0, []);
        if (categories.length === 0) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'At least one category must be defined');
        }
        const options = this.getNodeParameter('options', 0, {});
        const multiClass = options?.multiClass ?? false;
        const fallback = options?.fallback ?? 'discard';
        const schemaEntries = categories.map((cat) => [
            cat.category,
            zod_1.z
                .boolean()
                .describe(`Should be true if the input has category "${cat.category}" (description: ${cat.description})`),
        ]);
        if (fallback === 'other')
            schemaEntries.push([
                'fallback',
                zod_1.z.boolean().describe('Should be true if none of the other categories apply'),
            ]);
        const schema = zod_1.z.object(Object.fromEntries(schemaEntries));
        const structuredParser = output_parsers_1.StructuredOutputParser.fromZodSchema(schema);
        const parser = options.enableAutoFixing
            ? output_parsers_1.OutputFixingParser.fromLLM(llm, structuredParser)
            : structuredParser;
        const multiClassPrompt = multiClass
            ? 'Categories are not mutually exclusive, and multiple can be true'
            : 'Categories are mutually exclusive, and only one can be true';
        const fallbackPrompt = {
            other: 'If no categories apply, select the "fallback" option.',
            discard: 'If there is not a very fitting category, select none of the categories.',
        }[fallback];
        const returnData = Array.from({ length: categories.length + (fallback === 'other' ? 1 : 0) }, (_) => []);
        for (let itemIdx = 0; itemIdx < items.length; itemIdx++) {
            const item = items[itemIdx];
            item.pairedItem = { item: itemIdx };
            const input = this.getNodeParameter('inputText', itemIdx);
            const inputPrompt = new messages_1.HumanMessage(input);
            const systemPromptTemplateOpt = this.getNodeParameter('options.systemPromptTemplate', itemIdx, SYSTEM_PROMPT_TEMPLATE);
            const systemPromptTemplate = prompts_1.SystemMessagePromptTemplate.fromTemplate(`${systemPromptTemplateOpt ?? SYSTEM_PROMPT_TEMPLATE}
{format_instructions}
${multiClassPrompt}
${fallbackPrompt}`);
            const messages = [
                await systemPromptTemplate.format({
                    categories: categories.map((cat) => cat.category).join(', '),
                    format_instructions: parser.getFormatInstructions(),
                }),
                inputPrompt,
            ];
            const prompt = prompts_1.ChatPromptTemplate.fromMessages(messages);
            const chain = prompt.pipe(llm).pipe(parser).withConfig((0, tracing_1.getTracingConfig)(this));
            try {
                const output = await chain.invoke(messages);
                categories.forEach((cat, idx) => {
                    if (output[cat.category])
                        returnData[idx].push(item);
                });
                if (fallback === 'other' && output.fallback)
                    returnData[returnData.length - 1].push(item);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    returnData[0].push({
                        json: { error: error.message },
                        pairedItem: { item: itemIdx },
                    });
                    continue;
                }
                throw error;
            }
        }
        return returnData;
    }
}
exports.TextClassifier = TextClassifier;
//# sourceMappingURL=TextClassifier.node.js.map