"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPromptTemplate = createPromptTemplate;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const n8n_workflow_1 = require("n8n-workflow");
const helpers_1 = require("../../../../utils/helpers");
const imageUtils_1 = require("./imageUtils");
function buildQueryTemplate(formatInstructions) {
    return new prompts_1.PromptTemplate({
        template: `{query}${formatInstructions ? '\n{formatInstructions}' : ''}`,
        inputVariables: ['query'],
        partialVariables: formatInstructions ? { formatInstructions } : undefined,
    });
}
async function processMessageTemplates({ context, itemIndex, messages, }) {
    return await Promise.all(messages.map(async (message) => {
        const messageClass = [
            prompts_1.SystemMessagePromptTemplate,
            prompts_1.AIMessagePromptTemplate,
            prompts_1.HumanMessagePromptTemplate,
        ].find((m) => m.lc_name() === message.type);
        if (!messageClass) {
            throw new n8n_workflow_1.OperationalError('Invalid message type', {
                extra: { messageType: message.type },
            });
        }
        if (messageClass === prompts_1.HumanMessagePromptTemplate && message.messageType !== 'text') {
            return await (0, imageUtils_1.createImageMessage)({ context, itemIndex, message });
        }
        return messageClass.fromTemplate((message.message || '').replace(/[{}]/g, (match) => match + match));
    }));
}
async function finalizePromptTemplate({ parsedMessages, queryTemplate, query, }) {
    const lastMessage = parsedMessages[parsedMessages.length - 1];
    if (lastMessage instanceof messages_1.HumanMessage && Array.isArray(lastMessage.content)) {
        const humanMessage = new prompts_1.HumanMessagePromptTemplate(queryTemplate);
        const formattedMessage = await humanMessage.format({ query });
        if (Array.isArray(lastMessage.content)) {
            const updatedContent = [
                ...lastMessage.content,
                {
                    text: formattedMessage.content.toString(),
                    type: 'text',
                },
            ];
            lastMessage.content = updatedContent;
        }
    }
    else {
        parsedMessages.push(new prompts_1.HumanMessagePromptTemplate(queryTemplate));
    }
    return prompts_1.ChatPromptTemplate.fromMessages(parsedMessages);
}
async function createPromptTemplate({ context, itemIndex, llm, messages, formatInstructions, query, }) {
    const queryTemplate = buildQueryTemplate(formatInstructions);
    if (!(0, helpers_1.isChatInstance)(llm)) {
        return queryTemplate;
    }
    const parsedMessages = messages?.length
        ? await processMessageTemplates({ context, itemIndex, messages })
        : [];
    return await finalizePromptTemplate({
        parsedMessages,
        queryTemplate,
        query,
    });
}
//# sourceMappingURL=promptUtils.js.map