"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAgentStepsParser = void 0;
exports.getOutputParserSchema = getOutputParserSchema;
exports.extractBinaryMessages = extractBinaryMessages;
exports.fixEmptyContentMessage = fixEmptyContentMessage;
exports.handleAgentFinishOutput = handleAgentFinishOutput;
exports.handleParsedStepOutput = handleParsedStepOutput;
exports.getChatModel = getChatModel;
exports.getOptionalMemory = getOptionalMemory;
exports.getTools = getTools;
exports.prepareMessages = prepareMessages;
exports.preparePrompt = preparePrompt;
exports.toolsAgentExecute = toolsAgentExecute;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const runnables_1 = require("@langchain/core/runnables");
const tools_1 = require("@langchain/core/tools");
const agents_1 = require("langchain/agents");
const lodash_1 = require("lodash");
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
const helpers_1 = require("../../../../../utils/helpers");
const N8nOutputParser_1 = require("../../../../../utils/output_parsers/N8nOutputParser");
const prompt_1 = require("./prompt");
function getOutputParserSchema(outputParser) {
    const schema = outputParser.getSchema() ?? zod_1.z.object({ text: zod_1.z.string() });
    return schema;
}
async function extractBinaryMessages(ctx, itemIndex) {
    const binaryData = ctx.getInputData()?.[itemIndex]?.binary ?? {};
    const binaryMessages = await Promise.all(Object.values(binaryData)
        .filter((data) => data.mimeType.startsWith('image/'))
        .map(async (data) => {
        let binaryUrlString;
        if (data.id) {
            const binaryBuffer = await ctx.helpers.binaryToBuffer(await ctx.helpers.getBinaryStream(data.id));
            binaryUrlString = `data:${data.mimeType};base64,${Buffer.from(binaryBuffer).toString(n8n_workflow_1.BINARY_ENCODING)}`;
        }
        else {
            binaryUrlString = data.data.includes('base64')
                ? data.data
                : `data:${data.mimeType};base64,${data.data}`;
        }
        return {
            type: 'image_url',
            image_url: {
                url: binaryUrlString,
            },
        };
    }));
    return new messages_1.HumanMessage({
        content: [...binaryMessages],
    });
}
function fixEmptyContentMessage(steps) {
    if (!Array.isArray(steps))
        return steps;
    steps.forEach((step) => {
        if ('messageLog' in step && step.messageLog !== undefined) {
            if (Array.isArray(step.messageLog)) {
                step.messageLog.forEach((message) => {
                    if ('content' in message && Array.isArray(message.content)) {
                        message.content.forEach((content) => {
                            if (content.input === '') {
                                content.input = {};
                            }
                        });
                    }
                });
            }
        }
    });
    return steps;
}
function handleAgentFinishOutput(steps) {
    const agentFinishSteps = steps;
    if (agentFinishSteps.returnValues) {
        const isMultiOutput = Array.isArray(agentFinishSteps.returnValues?.output);
        if (isMultiOutput) {
            const multiOutputSteps = agentFinishSteps.returnValues.output;
            const isTextOnly = multiOutputSteps.every((output) => 'text' in output);
            if (isTextOnly) {
                agentFinishSteps.returnValues.output = multiOutputSteps
                    .map((output) => output.text)
                    .join('\n')
                    .trim();
            }
            return agentFinishSteps;
        }
    }
    return agentFinishSteps;
}
function handleParsedStepOutput(output, memory) {
    return {
        returnValues: memory ? { output: JSON.stringify(output) } : output,
        log: 'Final response formatted',
    };
}
const getAgentStepsParser = (outputParser, memory) => async (steps) => {
    if (Array.isArray(steps)) {
        const responseParserTool = steps.find((step) => step.tool === 'format_final_json_response');
        if (responseParserTool && outputParser) {
            const toolInput = responseParserTool.toolInput;
            const parserInput = toolInput instanceof Object ? JSON.stringify(toolInput) : toolInput;
            const returnValues = (await outputParser.parse(parserInput));
            return handleParsedStepOutput(returnValues, memory);
        }
    }
    if (outputParser && typeof steps === 'object' && steps.returnValues) {
        const finalResponse = steps.returnValues;
        let parserInput;
        if (finalResponse instanceof Object) {
            if ('output' in finalResponse) {
                try {
                    parserInput = JSON.stringify({ output: (0, n8n_workflow_1.jsonParse)(finalResponse.output) });
                }
                catch (error) {
                    parserInput = finalResponse.output;
                }
            }
            else {
                parserInput = JSON.stringify(finalResponse);
            }
        }
        else {
            parserInput = finalResponse;
        }
        const returnValues = (await outputParser.parse(parserInput));
        return handleParsedStepOutput(returnValues, memory);
    }
    return handleAgentFinishOutput(steps);
};
exports.getAgentStepsParser = getAgentStepsParser;
async function getChatModel(ctx) {
    const model = await ctx.getInputConnectionData("ai_languageModel", 0);
    if (!(0, helpers_1.isChatInstance)(model) || !model.bindTools) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'Tools Agent requires Chat Model which supports Tools calling');
    }
    return model;
}
async function getOptionalMemory(ctx) {
    return (await ctx.getInputConnectionData("ai_memory", 0));
}
async function getTools(ctx, outputParser) {
    const tools = (await (0, helpers_1.getConnectedTools)(ctx, true, false));
    if (outputParser) {
        const schema = getOutputParserSchema(outputParser);
        const structuredOutputParserTool = new tools_1.DynamicStructuredTool({
            schema,
            name: 'format_final_json_response',
            description: 'Use this tool to format your final response to the user in a structured JSON format. This tool validates your output against a schema to ensure it meets the required format. ONLY use this tool when you have completed all necessary reasoning and are ready to provide your final answer. Do not use this tool for intermediate steps or for asking questions. The output from this tool will be directly returned to the user.',
            func: async () => '',
        });
        tools.push(structuredOutputParserTool);
    }
    return tools;
}
async function prepareMessages(ctx, itemIndex, options) {
    const messages = [
        ['system', `{system_message}${options.outputParser ? '\n\n{formatting_instructions}' : ''}`],
        ['placeholder', '{chat_history}'],
        ['human', '{input}'],
    ];
    const hasBinaryData = ctx.getInputData()?.[itemIndex]?.binary !== undefined;
    if (hasBinaryData && options.passthroughBinaryImages) {
        const binaryMessage = await extractBinaryMessages(ctx, itemIndex);
        messages.push(binaryMessage);
    }
    messages.push(['placeholder', '{agent_scratchpad}']);
    return messages;
}
function preparePrompt(messages) {
    return prompts_1.ChatPromptTemplate.fromMessages(messages);
}
async function toolsAgentExecute() {
    this.logger.debug('Executing Tools Agent');
    const returnData = [];
    const items = this.getInputData();
    const outputParser = await (0, N8nOutputParser_1.getOptionalOutputParser)(this);
    const tools = await getTools(this, outputParser);
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
        try {
            const model = await getChatModel(this);
            const memory = await getOptionalMemory(this);
            const input = (0, helpers_1.getPromptInputByType)({
                ctx: this,
                i: itemIndex,
                inputKey: 'text',
                promptTypeKey: 'promptType',
            });
            if (input === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'The “text” parameter is empty.');
            }
            const options = this.getNodeParameter('options', itemIndex, {});
            const messages = await prepareMessages(this, itemIndex, {
                systemMessage: options.systemMessage,
                passthroughBinaryImages: options.passthroughBinaryImages ?? true,
                outputParser,
            });
            const prompt = preparePrompt(messages);
            const agent = (0, agents_1.createToolCallingAgent)({
                llm: model,
                tools,
                prompt,
                streamRunnable: false,
            });
            agent.streamRunnable = false;
            const runnableAgent = runnables_1.RunnableSequence.from([
                agent,
                (0, exports.getAgentStepsParser)(outputParser, memory),
                fixEmptyContentMessage,
            ]);
            const executor = agents_1.AgentExecutor.fromAgentAndTools({
                agent: runnableAgent,
                memory,
                tools,
                returnIntermediateSteps: options.returnIntermediateSteps === true,
                maxIterations: options.maxIterations ?? 10,
            });
            const response = await executor.invoke({
                input,
                system_message: options.systemMessage ?? prompt_1.SYSTEM_MESSAGE,
                formatting_instructions: 'IMPORTANT: For your response to user, you MUST use the `format_final_json_response` tool with your complete answer formatted according to the required schema. Do not attempt to format the JSON manually - always use this tool. Your response will be rejected if it is not properly formatted through this tool. Only use this tool once you are ready to provide your final answer.',
            }, { signal: this.getExecutionCancelSignal() });
            if (memory && outputParser) {
                const parsedOutput = (0, n8n_workflow_1.jsonParse)(response.output);
                response.output = parsedOutput?.output ?? parsedOutput;
            }
            const itemResult = {
                json: (0, lodash_1.omit)(response, 'system_message', 'formatting_instructions', 'input', 'chat_history', 'agent_scratchpad'),
            };
            returnData.push(itemResult);
        }
        catch (error) {
            if (this.continueOnFail()) {
                returnData.push({
                    json: { error: error.message },
                    pairedItem: { item: itemIndex },
                });
                continue;
            }
            throw error;
        }
    }
    return [returnData];
}
//# sourceMappingURL=execute.js.map