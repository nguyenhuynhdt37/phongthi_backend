"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStoreMongoDBAtlas = void 0;
const mongodb_1 = require("@langchain/mongodb");
const mongodb_2 = require("mongodb");
const n8n_workflow_1 = require("n8n-workflow");
const sharedFields_1 = require("../../../utils/sharedFields");
const createVectorStoreNode_1 = require("../shared/createVectorStoreNode/createVectorStoreNode");
const mongoCollectionRLC = {
    displayName: 'MongoDB Collection',
    name: 'mongoCollection',
    type: 'resourceLocator',
    default: { mode: 'list', value: '' },
    required: true,
    modes: [
        {
            displayName: 'From List',
            name: 'list',
            type: 'list',
            typeOptions: {
                searchListMethod: 'mongoCollectionSearch',
            },
        },
        {
            displayName: 'Name',
            name: 'name',
            type: 'string',
            placeholder: 'e.g. my_collection',
        },
    ],
};
const vectorIndexName = {
    displayName: 'Vector Index Name',
    name: 'vectorIndexName',
    type: 'string',
    default: '',
    description: 'The name of the vector index',
    required: true,
};
const embeddingField = {
    displayName: 'Embedding',
    name: 'embedding',
    type: 'string',
    default: 'embedding',
    description: 'The field with the embedding array',
    required: true,
};
const metadataField = {
    displayName: 'Metadata Field',
    name: 'metadata_field',
    type: 'string',
    default: 'text',
    description: 'The text field of the raw data',
    required: true,
};
const sharedFields = [
    mongoCollectionRLC,
    embeddingField,
    metadataField,
    vectorIndexName,
];
const mongoNamespaceField = {
    displayName: 'Namespace',
    name: 'namespace',
    type: 'string',
    description: 'Logical partition for documents. Uses metadata.namespace field for filtering.',
    default: '',
};
const retrieveFields = [
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [mongoNamespaceField, sharedFields_1.metadataFilterField],
    },
];
const insertFields = [
    {
        displayName: 'Options',
        name: 'options',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [
            {
                displayName: 'Clear Namespace',
                name: 'clearNamespace',
                type: 'boolean',
                default: false,
                description: 'Whether to clear documents in the namespace before inserting new data',
            },
            mongoNamespaceField,
        ],
    },
];
let mongoClient = null;
async function getMongoClient(context) {
    if (!mongoClient) {
        const credentials = await context.getCredentials('mongoDb');
        mongoClient = new mongodb_2.MongoClient(credentials.connectionString, {
            appName: 'devrel.integration.n8n_vector_integ',
        });
        await mongoClient.connect();
    }
    return mongoClient;
}
async function mongoClientAndDatabase(context) {
    const client = await getMongoClient(context);
    const credentials = await context.getCredentials('mongoDb');
    const db = client.db(credentials.database);
    return { client, db };
}
async function mongoCollectionSearch() {
    const { db } = await mongoClientAndDatabase(this);
    try {
        const collections = await db.listCollections().toArray();
        const results = collections.map((collection) => ({
            name: collection.name,
            value: collection.name,
        }));
        return { results };
    }
    catch (error) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Error: ${error.message}`);
    }
}
class VectorStoreMongoDBAtlas extends (0, createVectorStoreNode_1.createVectorStoreNode)({
    meta: {
        displayName: 'MongoDB Atlas Vector Store',
        name: 'vectorStoreMongoDBAtlas',
        description: 'Work with your data in MongoDB Atlas Vector Store',
        icon: { light: 'file:mongodb.svg', dark: 'file:mongodb.dark.svg' },
        docsUrl: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.vectorstoremongodbatlas/',
        credentials: [
            {
                name: 'mongoDb',
                required: true,
            },
        ],
        operationModes: ['load', 'insert', 'retrieve', 'update', 'retrieve-as-tool'],
    },
    methods: { listSearch: { mongoCollectionSearch } },
    retrieveFields,
    loadFields: retrieveFields,
    insertFields,
    sharedFields,
    async getVectorStoreClient(context, _filter, embeddings, itemIndex) {
        try {
            const { db } = await mongoClientAndDatabase(context);
            try {
                const collectionName = context.getNodeParameter('mongoCollection', itemIndex, '', {
                    extractValue: true,
                });
                const mongoVectorIndexName = context.getNodeParameter('vectorIndexName', itemIndex, '', {
                    extractValue: true,
                });
                const embeddingFieldName = context.getNodeParameter('embedding', itemIndex, '', {
                    extractValue: true,
                });
                const metadataFieldName = context.getNodeParameter('metadata_field', itemIndex, '', {
                    extractValue: true,
                });
                const collection = db.collection(collectionName);
                const indexes = await collection.listSearchIndexes().toArray();
                const indexExists = indexes.some((index) => index.name === mongoVectorIndexName);
                if (!indexExists) {
                    throw new n8n_workflow_1.NodeOperationError(context.getNode(), `Index ${mongoVectorIndexName} not found`, {
                        itemIndex,
                        description: 'Please check that the index exists in your collection',
                    });
                }
                return new mongodb_1.MongoDBAtlasVectorSearch(embeddings, {
                    collection,
                    indexName: mongoVectorIndexName,
                    textKey: metadataFieldName,
                    embeddingKey: embeddingFieldName,
                });
            }
            catch (error) {
                throw new n8n_workflow_1.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
                    itemIndex,
                    description: 'Please check your MongoDB Atlas connection details',
                });
            }
            finally {
            }
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
                itemIndex,
                description: 'Please check your MongoDB Atlas connection details',
            });
        }
    },
    async populateVectorStore(context, embeddings, documents, itemIndex) {
        try {
            const { db } = await mongoClientAndDatabase(context);
            try {
                const mongoCollectionName = context.getNodeParameter('mongoCollection', itemIndex, '', {
                    extractValue: true,
                });
                const embeddingFieldName = context.getNodeParameter('embedding', itemIndex, '', {
                    extractValue: true,
                });
                const metadataFieldName = context.getNodeParameter('metadata_field', itemIndex, '', {
                    extractValue: true,
                });
                const mongoDBAtlasVectorIndex = context.getNodeParameter('vectorIndexName', itemIndex, '', {
                    extractValue: true,
                });
                const collections = await db.listCollections({ name: mongoCollectionName }).toArray();
                if (collections.length === 0) {
                    await db.createCollection(mongoCollectionName);
                }
                const collection = db.collection(mongoCollectionName);
                await mongodb_1.MongoDBAtlasVectorSearch.fromDocuments(documents, embeddings, {
                    collection,
                    indexName: mongoDBAtlasVectorIndex,
                    textKey: metadataFieldName,
                    embeddingKey: embeddingFieldName,
                });
            }
            catch (error) {
                throw new n8n_workflow_1.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
                    itemIndex,
                    description: 'Please check your MongoDB Atlas connection details',
                });
            }
            finally {
            }
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
                itemIndex,
                description: 'Please check your MongoDB Atlas connection details',
            });
        }
    },
}) {
}
exports.VectorStoreMongoDBAtlas = VectorStoreMongoDBAtlas;
//# sourceMappingURL=VectorStoreMongoDBAtlas.node.js.map