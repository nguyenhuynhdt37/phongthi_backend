"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRetrieveAsToolOperation = handleRetrieveAsToolOperation;
const tools_1 = require("langchain/tools");
const helpers_1 = require("../../../../../utils/helpers");
const logWrapper_1 = require("../../../../../utils/logWrapper");
async function handleRetrieveAsToolOperation(context, args, embeddings, itemIndex) {
    const toolDescription = context.getNodeParameter('toolDescription', itemIndex);
    const toolName = context.getNodeParameter('toolName', itemIndex);
    const topK = context.getNodeParameter('topK', itemIndex, 4);
    const includeDocumentMetadata = context.getNodeParameter('includeDocumentMetadata', itemIndex, true);
    const filter = (0, helpers_1.getMetadataFiltersValues)(context, itemIndex);
    const vectorStoreTool = new tools_1.DynamicTool({
        name: toolName,
        description: toolDescription,
        func: async (input) => {
            const vectorStore = await args.getVectorStoreClient(context, undefined, embeddings, itemIndex);
            try {
                const embeddedPrompt = await embeddings.embedQuery(input);
                const documents = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);
                return documents
                    .map((document) => {
                    if (includeDocumentMetadata) {
                        return { type: 'text', text: JSON.stringify(document[0]) };
                    }
                    return {
                        type: 'text',
                        text: JSON.stringify({ pageContent: document[0].pageContent }),
                    };
                })
                    .filter((document) => !!document);
            }
            finally {
                args.releaseVectorStoreClient?.(vectorStore);
            }
        },
    });
    return {
        response: (0, logWrapper_1.logWrapper)(vectorStoreTool, context),
    };
}
//# sourceMappingURL=retrieveAsToolOperation.js.map