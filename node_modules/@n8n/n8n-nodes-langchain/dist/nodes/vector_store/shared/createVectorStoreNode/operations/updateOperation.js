"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleUpdateOperation = handleUpdateOperation;
const n8n_workflow_1 = require("n8n-workflow");
const helpers_1 = require("../../../../../utils/helpers");
const N8nJsonLoader_1 = require("../../../../../utils/N8nJsonLoader");
const processDocuments_1 = require("../../processDocuments");
const utils_1 = require("../utils");
async function handleUpdateOperation(context, args, embeddings) {
    if (!(0, utils_1.isUpdateSupported)(args)) {
        throw new n8n_workflow_1.NodeOperationError(context.getNode(), 'Update operation is not implemented for this Vector Store');
    }
    const items = context.getInputData();
    const loader = new N8nJsonLoader_1.N8nJsonLoader(context);
    const resultData = [];
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
        const itemData = items[itemIndex];
        const documentId = context.getNodeParameter('id', itemIndex, '', {
            extractValue: true,
        });
        const vectorStore = await args.getVectorStoreClient(context, undefined, embeddings, itemIndex);
        try {
            const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(loader, itemData, itemIndex);
            if (processedDocuments?.length !== 1) {
                throw new n8n_workflow_1.NodeOperationError(context.getNode(), 'Single document per item expected');
            }
            resultData.push(...serializedDocuments);
            await vectorStore.addDocuments(processedDocuments, {
                ids: [documentId],
            });
            (0, helpers_1.logAiEvent)(context, 'ai-vector-store-updated');
        }
        finally {
            args.releaseVectorStoreClient?.(vectorStore);
        }
    }
    return resultData;
}
//# sourceMappingURL=updateOperation.js.map