"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionPoolManager = void 0;
const crypto_1 = require("crypto");
let instance;
const ttl = 5 * 60 * 1000;
const cleanUpInterval = 60 * 1000;
class ConnectionPoolManager {
    static getInstance() {
        if (!instance) {
            instance = new ConnectionPoolManager();
        }
        return instance;
    }
    constructor() {
        this.map = new Map();
        process.on('exit', () => this.onShutdown());
        setInterval(() => this.cleanupStaleConnections(), cleanUpInterval);
    }
    makeKey({ credentials, nodeType, nodeVersion }) {
        return (0, crypto_1.createHash)('sha1')
            .update(JSON.stringify({
            credentials,
            nodeType,
            nodeVersion,
        }))
            .digest('base64');
    }
    async getConnection(options) {
        const key = this.makeKey(options);
        let value = this.map.get(key);
        if (!value) {
            value = {
                pool: await options.fallBackHandler(),
                cleanUpHandler: options.cleanUpHandler,
            };
        }
        this.map.set(key, { ...value, lastUsed: Date.now() });
        return value.pool;
    }
    cleanupStaleConnections() {
        const now = Date.now();
        for (const [key, { cleanUpHandler, lastUsed, pool }] of this.map.entries()) {
            if (now - lastUsed > ttl) {
                void cleanUpHandler(pool);
                this.map.delete(key);
            }
        }
    }
    async purgeConnections() {
        await Promise.all([...this.map.entries()].map(async ([key, value]) => {
            this.map.delete(key);
            return await value.cleanUpHandler(value.pool);
        }));
    }
    onShutdown() {
        for (const { cleanUpHandler, pool } of this.map.values()) {
            void cleanUpHandler(pool);
        }
    }
}
exports.ConnectionPoolManager = ConnectionPoolManager;
//# sourceMappingURL=connection-pool-manager.js.map