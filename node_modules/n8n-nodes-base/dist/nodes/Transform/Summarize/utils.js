"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fieldValueGetter = exports.NUMERICAL_AGGREGATIONS = void 0;
exports.checkIfFieldExists = checkIfFieldExists;
exports.splitData = splitData;
exports.aggregationToArray = aggregationToArray;
exports.aggregationToArrayWithOriginalTypes = aggregationToArrayWithOriginalTypes;
const lodash_1 = require("lodash");
const get_1 = __importDefault(require("lodash/get"));
const n8n_workflow_1 = require("n8n-workflow");
const AggregationDisplayNames = {
    append: 'appended_',
    average: 'average_',
    concatenate: 'concatenated_',
    count: 'count_',
    countUnique: 'unique_count_',
    max: 'max_',
    min: 'min_',
    sum: 'sum_',
};
exports.NUMERICAL_AGGREGATIONS = ['average', 'sum'];
function isEmpty(value) {
    return value === undefined || value === null || value === '';
}
function parseReturnData(returnData) {
    const regexBrackets = /[\]\["]/g;
    const regexSpaces = /[ .]/g;
    for (const key of Object.keys(returnData)) {
        if (key.match(regexBrackets)) {
            const newKey = key.replace(regexBrackets, '');
            returnData[newKey] = returnData[key];
            delete returnData[key];
        }
    }
    for (const key of Object.keys(returnData)) {
        if (key.match(regexSpaces)) {
            const newKey = key.replace(regexSpaces, '_');
            returnData[newKey] = returnData[key];
            delete returnData[key];
        }
    }
}
function parseFieldName(fieldName) {
    const regexBrackets = /[\]\["]/g;
    const regexSpaces = /[ .]/g;
    fieldName = fieldName.map((field) => {
        field = field.replace(regexBrackets, '');
        field = field.replace(regexSpaces, '_');
        return field;
    });
    return fieldName;
}
const fieldValueGetter = (disableDotNotation) => {
    if (disableDotNotation) {
        return (item, field) => item[field];
    }
    else {
        return (item, field) => (0, get_1.default)(item, field);
    }
};
exports.fieldValueGetter = fieldValueGetter;
function checkIfFieldExists(items, aggregations, getValue) {
    for (const aggregation of aggregations) {
        if (aggregation.field === '') {
            continue;
        }
        const exist = items.some((item) => getValue(item, aggregation.field) !== undefined);
        if (!exist) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The field '${aggregation.field}' does not exist in any items`);
        }
    }
}
function aggregate(items, entry, getValue) {
    const { aggregation, field } = entry;
    let data = [...items];
    if (exports.NUMERICAL_AGGREGATIONS.includes(aggregation)) {
        data = data.filter((item) => typeof getValue(item, field) === 'number' && !isEmpty(getValue(item, field)));
    }
    switch (aggregation) {
        case 'append':
            if (!entry.includeEmpty) {
                data = data.filter((item) => !isEmpty(getValue(item, field)));
            }
            return data.map((item) => getValue(item, field));
        case 'concatenate':
            const separateBy = entry.separateBy === 'other' ? entry.customSeparator : entry.separateBy;
            if (!entry.includeEmpty) {
                data = data.filter((item) => !isEmpty(getValue(item, field)));
            }
            return data
                .map((item) => {
                let value = getValue(item, field);
                if (typeof value === 'object') {
                    value = JSON.stringify(value);
                }
                if (typeof value === 'undefined') {
                    value = 'undefined';
                }
                return value;
            })
                .join(separateBy);
        case 'average':
            return (data.reduce((acc, item) => {
                return acc + getValue(item, field);
            }, 0) / data.length);
        case 'sum':
            return data.reduce((acc, item) => {
                return acc + getValue(item, field);
            }, 0);
        case 'min':
            let min;
            for (const item of data) {
                const value = getValue(item, field);
                if (value !== undefined && value !== null && value !== '') {
                    if (min === undefined || value < min) {
                        min = value;
                    }
                }
            }
            return min ?? null;
        case 'max':
            let max;
            for (const item of data) {
                const value = getValue(item, field);
                if (value !== undefined && value !== null && value !== '') {
                    if (max === undefined || value > max) {
                        max = value;
                    }
                }
            }
            return max ?? null;
        case 'countUnique':
            if (!entry.includeEmpty) {
                return new Set(data.map((item) => getValue(item, field)).filter((item) => !isEmpty(item)))
                    .size;
            }
            return new Set(data.map((item) => getValue(item, field))).size;
        default:
            if (!entry.includeEmpty) {
                return data.filter((item) => !isEmpty(getValue(item, field))).length;
            }
            return data.length;
    }
}
function aggregateData(data, fieldsToSummarize, options, getValue) {
    const returnData = fieldsToSummarize.reduce((acc, aggregation) => {
        acc[`${AggregationDisplayNames[aggregation.aggregation]}${aggregation.field}`] = aggregate(data, aggregation, getValue);
        return acc;
    }, {});
    parseReturnData(returnData);
    if (options.outputFormat === 'singleItem') {
        parseReturnData(returnData);
        return returnData;
    }
    else {
        return { ...returnData, pairedItems: data.map((item) => item._itemIndex) };
    }
}
function splitData(splitKeys, data, fieldsToSummarize, options, getValue) {
    if (!splitKeys || splitKeys.length === 0) {
        return aggregateData(data, fieldsToSummarize, options, getValue);
    }
    const [firstSplitKey, ...restSplitKeys] = splitKeys;
    const groupedData = data.reduce((acc, item) => {
        let keyValue = getValue(item, firstSplitKey);
        if (typeof keyValue === 'object') {
            keyValue = JSON.stringify(keyValue);
        }
        if (options.skipEmptySplitFields && typeof keyValue !== 'number' && !keyValue) {
            return acc;
        }
        if (acc[keyValue] === undefined) {
            acc[keyValue] = [item];
        }
        else {
            acc[keyValue].push(item);
        }
        return acc;
    }, {});
    return Object.keys(groupedData).reduce((acc, key) => {
        const value = groupedData[key];
        acc[key] = splitData(restSplitKeys, value, fieldsToSummarize, options, getValue);
        return acc;
    }, {});
}
function aggregationToArray(aggregationResult, fieldsToSplitBy, previousStage = {}) {
    const returnData = [];
    fieldsToSplitBy = parseFieldName(fieldsToSplitBy);
    const splitFieldName = fieldsToSplitBy[0];
    const isNext = fieldsToSplitBy[1];
    if (isNext === undefined) {
        for (const fieldName of Object.keys(aggregationResult)) {
            returnData.push({
                ...previousStage,
                [splitFieldName]: fieldName,
                ...aggregationResult[fieldName],
            });
        }
        return returnData;
    }
    else {
        for (const key of Object.keys(aggregationResult)) {
            returnData.push(...aggregationToArray(aggregationResult[key], fieldsToSplitBy.slice(1), {
                ...previousStage,
                [splitFieldName]: key,
            }));
        }
        return returnData;
    }
}
const getOriginalFieldValue = (field) => field === 'null' ? null : (0, lodash_1.isNaN)(Number(field)) ? field : Number(field);
function aggregationToArrayWithOriginalTypes(aggregationResult, fieldsToSplitBy, previousStage = {}) {
    const returnData = [];
    fieldsToSplitBy = parseFieldName(fieldsToSplitBy);
    const splitFieldName = fieldsToSplitBy[0];
    const isNext = fieldsToSplitBy[1];
    if (isNext === undefined) {
        for (const fieldName of Object.keys(aggregationResult)) {
            returnData.push({
                ...previousStage,
                [splitFieldName]: getOriginalFieldValue(fieldName),
                ...aggregationResult[fieldName],
            });
        }
        return returnData;
    }
    else {
        for (const key of Object.keys(aggregationResult)) {
            returnData.push(...aggregationToArray(aggregationResult[key], fieldsToSplitBy.slice(1), {
                ...previousStage,
                [splitFieldName]: getOriginalFieldValue(key),
            }));
        }
        return returnData;
    }
}
//# sourceMappingURL=utils.js.map