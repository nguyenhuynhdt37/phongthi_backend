"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNewEmails = getNewEmails;
const imap_1 = require("@n8n/imap");
const lodash_1 = require("lodash");
const mailparser_1 = require("mailparser");
const n8n_workflow_1 = require("n8n-workflow");
async function parseRawEmail(messageEncoded, dataPropertyNameDownload) {
    const responseData = await (0, mailparser_1.simpleParser)(messageEncoded);
    const headers = {};
    const additionalData = {};
    for (const header of responseData.headerLines) {
        headers[header.key] = header.line;
    }
    additionalData.headers = headers;
    additionalData.headerLines = undefined;
    const binaryData = {};
    if (responseData.attachments) {
        for (let i = 0; i < responseData.attachments.length; i++) {
            const attachment = responseData.attachments[i];
            binaryData[`${dataPropertyNameDownload}${i}`] = await this.helpers.prepareBinaryData(attachment.content, attachment.filename, attachment.contentType);
        }
        additionalData.attachments = undefined;
    }
    return {
        json: { ...responseData, ...additionalData },
        binary: Object.keys(binaryData).length ? binaryData : undefined,
    };
}
async function getNewEmails(imapConnection, searchCriteria, staticData, postProcessAction, getText, getAttachment) {
    const format = this.getNodeParameter('format', 0);
    let fetchOptions = {};
    if (format === 'simple' || format === 'raw') {
        fetchOptions = {
            bodies: ['TEXT', 'HEADER'],
            markSeen: false,
            struct: true,
        };
    }
    else if (format === 'resolved') {
        fetchOptions = {
            bodies: [''],
            markSeen: false,
            struct: true,
        };
    }
    const results = await imapConnection.search(searchCriteria, fetchOptions);
    const newEmails = [];
    let newEmail;
    let attachments;
    let propertyName;
    const topLevelProperties = ['cc', 'date', 'from', 'subject', 'to'];
    if (format === 'resolved') {
        const dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
        for (const message of results) {
            if (staticData.lastMessageUid !== undefined &&
                message.attributes.uid <= staticData.lastMessageUid) {
                continue;
            }
            if (staticData.lastMessageUid === undefined ||
                staticData.lastMessageUid < message.attributes.uid) {
                staticData.lastMessageUid = message.attributes.uid;
            }
            const part = (0, lodash_1.find)(message.parts, { which: '' });
            if (part === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
            }
            const parsedEmail = await parseRawEmail.call(this, part.body, dataPropertyAttachmentsPrefixName);
            newEmails.push(parsedEmail);
        }
    }
    else if (format === 'simple') {
        const downloadAttachments = this.getNodeParameter('downloadAttachments');
        let dataPropertyAttachmentsPrefixName = '';
        if (downloadAttachments) {
            dataPropertyAttachmentsPrefixName = this.getNodeParameter('dataPropertyAttachmentsPrefixName');
        }
        for (const message of results) {
            if (staticData.lastMessageUid !== undefined &&
                message.attributes.uid <= staticData.lastMessageUid) {
                continue;
            }
            if (staticData.lastMessageUid === undefined ||
                staticData.lastMessageUid < message.attributes.uid) {
                staticData.lastMessageUid = message.attributes.uid;
            }
            const parts = (0, imap_1.getParts)(message.attributes.struct);
            newEmail = {
                json: {
                    textHtml: await getText(parts, message, 'html'),
                    textPlain: await getText(parts, message, 'plain'),
                    metadata: {},
                },
            };
            const messageHeader = message.parts.filter((part) => part.which === 'HEADER');
            const messageBody = messageHeader[0].body;
            for (propertyName of Object.keys(messageBody)) {
                if (messageBody[propertyName].length) {
                    if (topLevelProperties.includes(propertyName)) {
                        newEmail.json[propertyName] = messageBody[propertyName][0];
                    }
                    else {
                        newEmail.json.metadata[propertyName] = messageBody[propertyName][0];
                    }
                }
            }
            if (downloadAttachments) {
                attachments = await getAttachment(imapConnection, parts, message);
                if (attachments.length) {
                    newEmail.binary = {};
                    for (let i = 0; i < attachments.length; i++) {
                        newEmail.binary[`${dataPropertyAttachmentsPrefixName}${i}`] = attachments[i];
                    }
                }
            }
            newEmails.push(newEmail);
        }
    }
    else if (format === 'raw') {
        for (const message of results) {
            if (staticData.lastMessageUid !== undefined &&
                message.attributes.uid <= staticData.lastMessageUid) {
                continue;
            }
            if (staticData.lastMessageUid === undefined ||
                staticData.lastMessageUid < message.attributes.uid) {
                staticData.lastMessageUid = message.attributes.uid;
            }
            const part = (0, lodash_1.find)(message.parts, { which: 'TEXT' });
            if (part === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Email part could not be parsed.');
            }
            newEmail = {
                json: {
                    raw: part.body,
                },
            };
            newEmails.push(newEmail);
        }
    }
    if (postProcessAction === 'read') {
        const uidList = results.map((e) => e.attributes.uid);
        if (uidList.length > 0) {
            await imapConnection.addFlags(uidList, '\\SEEN');
        }
    }
    return newEmails;
}
//# sourceMappingURL=utils.js.map