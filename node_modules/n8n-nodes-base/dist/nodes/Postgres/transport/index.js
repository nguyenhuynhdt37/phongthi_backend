"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configurePostgres = configurePostgres;
const node_net_1 = require("node:net");
const pg_promise_1 = __importDefault(require("pg-promise"));
const connection_pool_manager_1 = require("../../../utils/connection-pool-manager");
const constants_1 = require("../../../utils/constants");
const utilities_1 = require("../../../utils/utilities");
const getPostgresConfig = (credentials, options = {}) => {
    const dbConfig = {
        host: credentials.host,
        port: credentials.port,
        database: credentials.database,
        user: credentials.user,
        password: credentials.password,
        keepAlive: true,
        max: credentials.maxConnections,
    };
    if (options.connectionTimeout) {
        dbConfig.connectionTimeoutMillis = options.connectionTimeout * 1000;
    }
    if (options.delayClosingIdleConnection) {
        dbConfig.keepAliveInitialDelayMillis = options.delayClosingIdleConnection * 1000;
    }
    if (credentials.allowUnauthorizedCerts === true) {
        dbConfig.ssl = {
            rejectUnauthorized: false,
        };
    }
    else {
        dbConfig.ssl = !['disable', undefined].includes(credentials.ssl);
        dbConfig.sslmode = credentials.ssl || 'disable';
    }
    return dbConfig;
};
async function configurePostgres(credentials, options = {}) {
    const poolManager = connection_pool_manager_1.ConnectionPoolManager.getInstance();
    const fallBackHandler = async () => {
        const pgp = (0, pg_promise_1.default)({
            noWarnings: true,
        });
        if (typeof options.nodeVersion === 'number' && options.nodeVersion >= 2.1) {
            [pgp.pg.types.builtins.TIMESTAMP, pgp.pg.types.builtins.TIMESTAMPTZ].forEach((type) => {
                pgp.pg.types.setTypeParser(type, (value) => {
                    const parsedDate = new Date(value);
                    if (isNaN(parsedDate.getTime())) {
                        return value;
                    }
                    return parsedDate.toISOString();
                });
            });
        }
        if (options.largeNumbersOutput === 'numbers') {
            pgp.pg.types.setTypeParser(20, (value) => {
                return parseInt(value, 10);
            });
            pgp.pg.types.setTypeParser(1700, (value) => {
                return parseFloat(value);
            });
        }
        const dbConfig = getPostgresConfig(credentials, options);
        if (!credentials.sshTunnel) {
            const db = pgp(dbConfig);
            return { db, pgp };
        }
        else {
            if (credentials.sshAuthenticateWith === 'privateKey' && credentials.privateKey) {
                credentials.privateKey = (0, utilities_1.formatPrivateKey)(credentials.privateKey);
            }
            const sshClient = await this.helpers.getSSHClient(credentials);
            const proxy = (0, node_net_1.createServer)();
            const proxyPort = await new Promise((resolve) => {
                proxy.listen(0, constants_1.LOCALHOST, () => {
                    resolve(proxy.address().port);
                });
            });
            const close = () => {
                proxy.close();
                sshClient.off('end', close);
                sshClient.off('error', close);
            };
            sshClient.on('end', close);
            sshClient.on('error', close);
            await new Promise((resolve, reject) => {
                proxy.on('error', (err) => reject(err));
                proxy.on('connection', (localSocket) => {
                    sshClient.forwardOut(constants_1.LOCALHOST, localSocket.remotePort, credentials.host, credentials.port, (err, clientChannel) => {
                        if (err) {
                            proxy.close();
                            localSocket.destroy();
                        }
                        else {
                            localSocket.pipe(clientChannel);
                            clientChannel.pipe(localSocket);
                        }
                    });
                });
                resolve();
            }).catch((err) => {
                proxy.close();
                let message = err.message;
                let description = err.description;
                if (err.message.includes('ECONNREFUSED')) {
                    message = 'Connection refused';
                    try {
                        description = err.message.split('ECONNREFUSED ')[1].trim();
                    }
                    catch (e) { }
                }
                if (err.message.includes('ENOTFOUND')) {
                    message = 'Host not found';
                    try {
                        description = err.message.split('ENOTFOUND ')[1].trim();
                    }
                    catch (e) { }
                }
                if (err.message.includes('ETIMEDOUT')) {
                    message = 'Connection timed out';
                    try {
                        description = err.message.split('ETIMEDOUT ')[1].trim();
                    }
                    catch (e) { }
                }
                err.message = message;
                err.description = description;
                throw err;
            });
            const db = pgp({
                ...dbConfig,
                port: proxyPort,
                host: constants_1.LOCALHOST,
            });
            return { db, pgp };
        }
    };
    return await poolManager.getConnection({
        credentials,
        nodeType: 'postgres',
        nodeVersion: options.nodeVersion,
        fallBackHandler,
        cleanUpHandler: async ({ db }) => {
            if (!db.$pool.ended)
                await db.$pool.end();
        },
    });
}
//# sourceMappingURL=index.js.map